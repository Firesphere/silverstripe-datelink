<?php

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * Description of DateLinkRouter
 *
 * @author Damo
 */
class DateLinkRouter implements IDateLinkRouter
{
    protected $dateField;
    protected $classNames = array();
    protected $controllerClass = 'DateLinkController';

    /**
     * File used to store routing table
     * This is required as database access is not accessible during routing, so these tables must be
     * built during dev/build and read during page init
     * @var string routing
     */
    protected $routeCache = '_datelink/Routing.xml';

    public function __construct($dateField)
    {
        $this->dateField = $dateField;
        $this->init();
    }

    protected function init()
    {
        // Automatically decorates pages with required helper functions
        $this->decoratePage();

        // DateLinkRouter always relies on previous instances of this class to generate routing tables, as 
        // routing always must be prepared before the database is ready. Therefore we do not need to worry about 
        // changes to the routing table this request, only that this file is kept up to date.
        $this->registerRoutes();
    }

    public function setDateField($field)
    {
        $this->dateField = $field;
    }

    public function getDateField()
    {
        return $this->dateField;
    }

    public function RegisterClass($className)
    {
        $this->classNames[] = $className;
        DataObject::add_extension($className, 'DateLinkHolderDecorator');
    }

    protected function getCacheFilePath()
    {
        return ASSETS_PATH . '/' . $this->routeCache;
    }

    /**
     * Registers all cached routes with silverstripe 
     */
    protected function registerRoutes()
    {
        $cachePath = $this->getCacheFilePath();
        if (!file_exists($cachePath))
            return Debug::message('DateLink route cache file could not be found. This can be generated by using /dev/build');

        $document = new DOMDocument();
        $document->load($cachePath);

        foreach ($document->getElementsByTagName('route') as $route)
        {
            $link = $route->getElementsByTagName('link')->item(0)->nodeValue;
            $parentID = $route->getElementsByTagName('page_id')->item(0)->nodeValue;
            $years = $route->getElementsByTagName('year');
            foreach ($years as $year)
                $this->registerRoute($link, $parentID, $year->nodeValue);
        }
    }

    protected function registerRoute($link, $parentID, $yearNumber)
    {
        $trimmedLink = trim($link, '/');
        if(!empty($trimmedLink))
            $trimmedLink .= '/'; // considers situation where we could be using the home page
        $pattern = '$Month!/$URLSegment!//$Action/$ID/$OtherID';
        $fullPattern = "$trimmedLink$yearNumber/$pattern";
        
        // Registers a route with
        Director::addRules(20,array($fullPattern => array(
            'Controller' => $this->controllerClass,
            'ParentID' => $parentID, // Used as a shortcut for simplifying nested routing
            'Year' => $yearNumber
        )));
    }

    protected function decoratePage()
    {
        DataObject::add_extension('Page', 'DateLinkPageDecorator');
    }

    /**
     * Determines the distinct years in the set of all pages given
     * @param DataObjectSet $pages 
     */
    protected function determineYears(DataObjectSet $pages)
    {
        $years = array();
        foreach ($pages as $page)
        {
            $date = $page->getField($this->dateField);
            if (!$date)
                continue;
            $parsedDate = date_parse($date);
            $years[] = $parsedDate['year'];
        }
        return array_unique($years);
    }

    public function RefreshCache()
    {
// Builds XML cache file using all available routes
        $document = new DOMDocument();
        $document->formatOutput = true;
        $routes = $document->createElement('routes');
        $document->appendChild($routes);

// append all routes
        foreach ($this->classNames as $className)
            foreach (DataObject::get($className) as $holderPage)
            {
                $route = $document->createElement('route');
                $link = $document->createElement('link', $holderPage->Link());
                $route->appendChild($link);
                $id = $document->createElement('page_id', $holderPage->ID);
                $route->appendChild($id);

                // Run through children and pull out all distinct year fields
                // We must use years in our URLS to distinguish all routes from non-numeric routes such as
                // page actions. It's not necessary to consider months, as by then the route will be sufficiently
                // distinguished.
                $children = DataObject::get('Page', "ParentID = {$holderPage->ID}");
                $yearList = $this->determineYears($children);
                $years = $document->createElement('years');
                foreach ($yearList as $yearNumber)
                {
                    $year = $document->createElement('year', $yearNumber);
                    $years->appendChild($year);
                }
                $route->appendChild($years);
                $routes->appendChild($route);
            }

// Ensure output directory exists
        $outputPath = $this->getCacheFilePath();

        Filesystem::makeFolder(dirname($outputPath));
        $document->save($outputPath);
    }

}