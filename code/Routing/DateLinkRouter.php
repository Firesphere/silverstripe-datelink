<?php

/**
 * Handles all routing pattern setup within the Silverstripe routing tables
 * @author Damian Mooyman
 */
class DateLinkRouter implements IDateLinkRouter
{

    /**
     * Name of database field to use when extracting dates from child pages.
     * Currently this is restricted to a single value, but you could easily create a wrapper for this in your code
     * with a getURLDate function and set it to this.
     * @var string
     */
    protected $dateField;

    /**
     * Pattern to use when building as well as routing links. Using one variable for both purposes keeps things consistent
     * @see DateLink::$default_url_pattern
     * @var string
     */
    protected $urlPattern;

    /**
     * List of class names that have been registered as parent pages of date-mapped urls
     * @var array
     */
    protected $classNames = array();

    /**
     * Class name to use for implementation of the controller class that will handle all routed requests
     * Should be a subclass of Controller
     * @see Controller
     * @var string
     */
    protected $controllerClass = 'DateLinkController';

    /**
     * Filename used to store routing table
     * This is required as database access is not accessible during routing, so these tables must be
     * built during dev/build and read during page init.
     * This file will be created under assets folder as it's a writable file, and I don't by policy put
     * writable files outside of this location.
     * @var string
     */
    protected $routeCache = '_datelink/Routing.xml';

    /**
     * Construct this instance of the routing handler
     * @param string $dateField Name of database field to use when extracting dates from child pages.
     * @param string $urlPattern
     */
    public function __construct($dateField, $urlPattern)
    {
        $this->dateField = $dateField;
        $this->urlPattern = $urlPattern;
        $this->init();
    }

    /**
     * Sets up this module. By default, if this module is never referenced in user code nothing is ever constructed.
     * This is used as a trigger to flag when this module is enabled, rather than by explicitly calling setup somewhere.
     */
    protected function init()
    {
        // Automatically decorates pages with required helper functions
        $this->decoratePage();

        // DateLinkRouter always relies on previous instances of this class to generate routing tables, as 
        // routing always must be prepared before the database is ready. Therefore we do not need to worry about 
        // changes to the routing table this request, only that this file is kept up to date.
        $this->registerRoutes();
    }

    /**
     * Sets the field to extract the date from
     * @param string $field Name of the date field
     */
    public function setDateField($field)
    {
        $this->dateField = $field;
    }

    /**
     * Gets the field to extract the date from
     * @return string Name of the date field
     */
    public function getDateField()
    {
        return $this->dateField;
    }

    /**
     * Sets the pattern to use when routing and generating links
     * @param string $pattern The pattern to use
     */
    public function setURLPattern($pattern)
    {
        $this->urlPattern = $pattern;
    }

    /**
     * Gets the pattern to use when routing and generating links
     * @return string The pattern used
     */
    public function getURLPattern()
    {
        return $this->urlPattern;
    }

    /**
     * Registers a class beneath which all child pages will be date-mapped.
     * @param type $className Name of the class to register
     * @param callback|boolean $filter a boolean, callback, or other closure that can be passed instances of the
     * specified class to determine if it should be consitered when filtering
     */
    public function RegisterClass($className, $filter = true)
    {
        $this->classNames[$className] = $filter;
        DataObject::add_extension($className, 'DateLinkHolderDecorator');
    }

    protected function getCacheFilePath()
    {
        return ASSETS_PATH . '/' . $this->routeCache;
    }

    /**
     * Registers all cached routes with silverstripe 
     */
    protected function registerRoutes()
    {
        $cachePath = $this->getCacheFilePath();
        if (!file_exists($cachePath))
            return Debug::message('DateLink route cache file could not be found. This can be generated by using /dev/build');

        $document = new DOMDocument();
        $document->load($cachePath);

        foreach ($document->getElementsByTagName('route') as $route)
        {
            $link = $route->getElementsByTagName('link')->item(0)->nodeValue;
            $parentID = $route->getElementsByTagName('page_id')->item(0)->nodeValue;
            $years = $route->getElementsByTagName('year');
            foreach ($years as $year)
                $this->registerRoute($link, $parentID, $year->nodeValue);
        }
    }

    /**
     * Registers a single routing rule within silverstripe
     * @param string $parentLink The link of the parent page
     * @param integer $parentID The ID of the parent page
     * @param integer $yearNumber The value of the $Year parameter
     */
    protected function registerRoute($parentLink, $parentID, $yearNumber)
    {
        $parentLink = trim($parentLink, '/');
        $pattern = $this->urlPattern;

        // Replace wildcards in pattern
        // Substitute leading-zero indicators
        $pattern = preg_replace('/#\$/', '$', $pattern);
        // substitute the year
        $pattern = preg_replace('/\$Year!?/i', $yearNumber, $pattern);
        // substitute parent url
        $pattern = preg_replace('/\$ParentLink!?/', $parentLink, $pattern);
        // Fix any extra slashes, which may occur if the $parentLink is /
        $pattern = trim($pattern, '/');

        // Registers a route with silverstripe
        Director::addRules(20,
                array($pattern => array(
                'Controller' => $this->controllerClass,
                'ParentID' => $parentID, // Used as a shortcut for simplifying nested routing
                'Year' => $yearNumber
                )));
    }

    protected function decoratePage()
    {
        DataObject::add_extension('Page', 'DateLinkPageDecorator');
    }

    /**
     * Determines the distinct years in the set of all pages given
     * @param DataObjectSet $pages 
     */
    protected function determineYears(DataObjectSet $pages)
    {
        $years = array();
        foreach ($pages as $page)
        {
            $date = $page->getField($this->dateField);
            if (!$date)
                continue;
            $parsedDate = date_parse($date);
            $years[] = $parsedDate['year'];
        }
        return array_unique($years);
    }

    /**
     * Instructs the module to refresh the routing XML cache file
     * This may not be called during manifest initialisation (_config.php) as database access is not available
     */
    public function RefreshCache()
    {
        // Builds XML cache file using all available routes
        $document = new DOMDocument();
        $document->formatOutput = true;
        $routes = $document->createElement('routes');
        $document->appendChild($routes);

        // append all routes
        foreach ($this->classNames as $className => $filter)
            foreach (DataObject::get($className) as $holderPage)
            {
                // Apply any specified filter
                if (is_callable($filter))
                {
                    if (!call_user_func($filter, $holderPage))
                        continue;
                }
                elseif (!$filter) // Fallback to using boolean filter
                    continue;

                $route = $document->createElement('route');
                $link = $document->createElement('link', $holderPage->Link());
                $route->appendChild($link);
                $id = $document->createElement('page_id', $holderPage->ID);
                $route->appendChild($id);

                // Run through children and pull out all distinct year fields
                // We must use years in our URLS to distinguish all routes from non-numeric routes such as
                // page actions. It's not necessary to consider months, as by then the route will be sufficiently
                // distinguished.
                $children = DataObject::get('Page', "ParentID = {$holderPage->ID}");
                $yearList = $this->determineYears($children);
                $years = $document->createElement('years');
                foreach ($yearList as $yearNumber)
                {
                    $year = $document->createElement('year', $yearNumber);
                    $years->appendChild($year);
                }
                $route->appendChild($years);
                $routes->appendChild($route);
            }

        // Ensure output directory exists
        $outputPath = $this->getCacheFilePath();

        Filesystem::makeFolder(dirname($outputPath));
        $document->save($outputPath);
    }

}